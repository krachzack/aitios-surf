use std::io;
use std::slice;
use geom::{Position, Normal, Vec3, InnerSpace};
use nearest_kdtree::KdTree;
use nearest_kdtree::distance::squared_euclidean;

/// Represents the surface of a mesh as a point-based model
/// Surface elements are stored sequentially in a flat vector,
/// indexed by a spatial index implemented as a kd-tree.
pub struct Surface<S : Position> {
    pub samples: Vec<S>,
    pub spatial_idx: KdTree<usize, [f64; 3]>
}

impl<S : Position> Surface<S> {

    /// Generates a OBJ file contianing the locations of all points
    /// contained in the given surface and writes them to the given
    /// sink, e.g. a file.
    ///
    /// OBJ files usually do support points, the resulting format is
    /// non-standard but can be read at least with blender.
    ///
    /// A better alternative would be creating PLY files, which could also
    /// encode other properties of the surfels other than position.
    pub fn dump<W : io::Write>(&self, sink: &mut W) -> io::Result<usize> {
        let mut written : usize = 0;

        written += sink.write("# Surface Model\n".as_bytes())?;
        written += sink.write("# Generated by surf.rs\n\n".as_bytes())?;

        written += sink.write("g surface\n\n".as_bytes())?;

        for point in self.samples.iter().map(S::position) {
            // Write all the points as vertices
            let vertex_line = format!("v {} {} {}\n", point.x, point.y, point.z);
            written += sink.write(vertex_line.as_bytes())?;
        }

        written += sink.write("\n".as_bytes())?;

        // OBJ indices are 1-based, hence +1
        for idx in (0+1)..(self.samples.len()+1) {
            // Write points as 1-dimensional faces
            let face_line = format!("f {}\n", idx);
            written += sink.write(face_line.as_bytes())?;
        }

        Ok(written)
    }

    /// Returns a mutable reference to the point nearest to the given
    /// location.
    pub fn nearest_mut<'a>(&'a mut self, from: Vec3) -> &'a mut S {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        &mut self.samples[nearest_idx]
    }

    pub fn nearest<'a>(&'a self, from: Vec3) -> &'a S {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        &self.samples[nearest_idx]
    }

    pub fn nearest_idx<'a>(&'a self, from: Vec3) -> usize {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        nearest_idx
    }

    /// Returns the `count` points in the surface which are nearest to the location
    /// specified with `from` as pairs containing the squared distance of the surfel to
    /// `from` as the first datum and a reference to the surfel as the second.
    pub fn nearest_n<'a>(&'a self, from: Vec3, count: usize) -> Vec<(f32, &'a S)> {
        assert!(self.samples.len() >= count);

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let nearest_idxs = self.spatial_idx.nearest(&[x, y, z], count, &squared_euclidean).unwrap();

        nearest_idxs.iter()
            .map(|n| (n.0 as f32, &self.samples[*n.1]))
            .collect()
    }

    pub fn nearest_n_indexes<'a>(&'a self, from: Vec3, count: usize) -> Vec<(f32, usize)> {
        assert!(self.samples.len() >= count);

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        self.spatial_idx.nearest(&[x, y, z], count, &squared_euclidean).unwrap()
            .into_iter()
            .map(|n| (n.0 as f32, *n.1))
            .collect()
    }

    /// Queries the n nearest surfels from the given point with the given normal. Surfels
    /// where the normal is rotated by more than the given cosine of an angle with respect
    /// to the search normal are filtered out. This ensures surfels from the other side of
    /// a thin layer will not influence the surfels on the other side.
    ///
    /// E.g. a `angle_threshold_cos` of cos(PI/2) = 0.0 will only allow rotations of up to 90째,
    /// while cos(PI/4) = 0.7071067812 will only allow 45째.
    pub fn nearest_n_indexes_oriented<'a>(&'a self, from: Vec3, normal: Vec3, angle_threshold_cos: f32, count: usize) -> Vec<(f32, usize)>
        where S : Normal
    {
        assert!(self.samples.len() >= count);

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        self.spatial_idx.iter_nearest(&[x, y, z], &squared_euclidean).unwrap()
            .filter(|n| {
                let surfel_normal = self.samples[*n.1].normal();
                surfel_normal.dot(normal) > angle_threshold_cos
            })
            .map(|n| (n.0 as f32, *n.1))
            .take(count)
            .collect()
    }

    pub fn iter<'a>(&'a self) -> slice::Iter<'a, S> {
        self.samples.iter()
    }

    pub fn find_within_sphere<'a>(&'a self, center: Vec3, radius: f32) -> Vec<&'a S> {
        let radius_sqr = (radius * radius) as f64;

        self.spatial_idx.within(
            &[center.x as f64, center.y as f64, center.z as f64],
            radius_sqr,
            &squared_euclidean
        ).unwrap().iter().map(move |&(_, &idx)| &self.samples[idx]).collect()
    }

    pub fn iter_mut<'a>(&'a mut self) -> slice::IterMut<'a, S> {
        self.samples.iter_mut()
    }

    pub fn find_within_sphere_indexes(&self, center: Vec3, radius: f32) -> Vec<usize> {
        let radius_sqr = (radius * radius) as f64;

        self.spatial_idx.within(
            &[center.x as f64, center.y as f64, center.z as f64],
            radius_sqr,
            &squared_euclidean
        ).unwrap().iter().map(move |&(_, &idx)| idx).collect()
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use SurfaceBuilder;
    use SurfelSampling;
    use geom::{TupleTriangle, Vertex, FromVertices, Vec2};

    #[test]
    fn test_nearest_oriented() {
        let triangles = unit_quad();

        let surf = SurfaceBuilder::new()
            .sampling(SurfelSampling::MinimumDistance(0.05))
            .sample_triangles(triangles.into_iter(), &())
            .build();

        assert!(surf.samples.len() > 50, "Expected at least 50 samples on a square with side length 1 and minimum sample distance of 0.05, but found {}", surf.samples.len());

        let nearest_same_normal = surf.nearest_n_indexes_oriented(
            Vec3::new(0.5, 0.5, 0.0),
            Vec3::new(0.0, 0.0, 1.0),
            0.0,
            50
        );
        assert_eq!(nearest_same_normal.len(), 50, "Searching for surfels with same normal at center of quad, but did not find as many as expected");

        let nearest_orthogonal_normal = surf.nearest_n_indexes_oriented(
            Vec3::new(0.5, 0.5, 0.0),
            Vec3::new(1.0, 0.0, 0.0),
            0.0,
            50
        );
        assert_eq!(nearest_orthogonal_normal.len(), 0, "Searched for surfels with 90째 rotated normal and expected to find nothing, but did find something");

        let nearest_flipped_normal = surf.nearest_n_indexes_oriented(
            Vec3::new(0.5, 0.5, 0.0),
            Vec3::new(0.0, 0.0, -1.0),
            0.0,
            50
        );
        assert_eq!(nearest_flipped_normal.len(), 0, "Searched for surfels with 180째 rotated normal and expected to find nothing, but did find something");
    }

    /// Makes a quad with one vertex at the origin (0.0, 0.0, 0.0), and one at (1.0, 1.0, 0.0).
    fn unit_quad() -> Vec<TupleTriangle<Vertex>> {
        let normal = Vec3::new(0.0, 0.0, 1.0);

        let vtx_bottom_left = Vertex {
            position: Vec3::new(0.0, 0.0, 0.0),
            texcoords: Vec2::new(0.0, 0.0),
            normal
        };
        let vtx_bottom_right = Vertex {
            position: Vec3::new(1.0, 0.0, 0.0),
            texcoords: Vec2::new(1.0, 0.0),
            normal
        };
        let vtx_top_right = Vertex {
            position: Vec3::new(1.0, 1.0, 0.0),
            texcoords: Vec2::new(1.0, 1.0),
            normal
        };
        let vtx_top_left = Vertex {
            position: Vec3::new(0.0, 1.0, 0.0),
            texcoords: Vec2::new(0.0, 1.0),
            normal
        };

        vec![
            TupleTriangle::new(
                vtx_bottom_left.clone(), vtx_bottom_right, vtx_top_right.clone()
            ),
            TupleTriangle::new(
                vtx_top_right, vtx_top_left, vtx_bottom_left
            ),
        ]
    }
}
