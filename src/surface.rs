use std::io;
use std::slice;
use geom::{Position, Vector3};
use nearest_kdtree::KdTree;
use nearest_kdtree::distance::squared_euclidean;

/// Represents the surface of a mesh as a point-based model
/// Surface elements are stored sequentially in a flat vector,
/// indexed by a spatial index implemented as a kd-tree.
pub struct Surface<S : Position> {
    pub samples: Vec<S>,
    pub spatial_idx: KdTree<usize, [f64; 3]>
}

impl<S : Position> Surface<S> {

    /// Generates a OBJ file contianing the locations of all points
    /// contained in the given surface and writes them to the given
    /// sink, e.g. a file.
    ///
    /// OBJ files usually do support points, the resulting format is
    /// non-standard but can be read at least with blender.
    ///
    /// A better alternative would be creating PLY files, which could also
    /// encode other properties of the surfels other than position.
    pub fn dump<W : io::Write>(&self, sink: &mut W) -> io::Result<usize> {
        let mut written : usize = 0;

        written += sink.write("# Surface Model\n".as_bytes())?;
        written += sink.write("# Generated by surf.rs\n\n".as_bytes())?;

        written += sink.write("g surface\n\n".as_bytes())?;

        for point in self.samples.iter().map(S::position) {
            // Write all the points as vertices
            let vertex_line = format!("v {} {} {}\n", point.x, point.y, point.z);
            written += sink.write(vertex_line.as_bytes())?;
        }

        written += sink.write("\n".as_bytes())?;

        // OBJ indices are 1-based, hence +1
        for idx in (0+1)..(self.samples.len()+1) {
            // Write points as 1-dimensional faces
            let face_line = format!("f {}\n", idx);
            written += sink.write(face_line.as_bytes())?;
        }

        Ok(written)
    }

    /// Returns a mutable reference to the point nearest to the given
    /// location.
    pub fn nearest_mut<'a>(&'a mut self, from: Vector3<f32>) -> &'a mut S {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        &mut self.samples[nearest_idx]
    }

    pub fn nearest<'a>(&'a self, from: Vector3<f32>) -> &'a S {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        &self.samples[nearest_idx]
    }

    pub fn nearest_idx<'a>(&'a self, from: Vector3<f32>) -> usize {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        nearest_idx
    }

    /// Returns the `count` points in the surface which are nearest to the location
    /// specified with `from` as pairs containing the squared distance of the surfel to
    /// `from` as the first datum and a reference to the surfel as the second.
    pub fn nearest_n<'a>(&'a self, from: Vector3<f32>, count: usize) -> Vec<(f32, &'a S)> {
        assert!(self.samples.len() >= count);

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let nearest_idxs = self.spatial_idx.nearest(&[x, y, z], count, &squared_euclidean).unwrap();

        nearest_idxs.iter()
            .map(|n| (n.0 as f32, &self.samples[*n.1]))
            .collect()
    }

    pub fn nearest_n_indexes<'a>(&'a self, from: Vector3<f32>, count: usize) -> Vec<(f32, usize)> {
        assert!(self.samples.len() >= count);

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        self.spatial_idx.nearest(&[x, y, z], count, &squared_euclidean).unwrap()
            .into_iter()
            .map(|n| (n.0 as f32, *n.1))
            .collect()
    }

    pub fn iter<'a>(&'a self) -> slice::Iter<'a, S> {
        self.samples.iter()
    }

    pub fn find_within_sphere<'a>(&'a self, center: Vector3<f32>, radius: f32) -> Vec<&'a S> {
        let radius_sqr = (radius * radius) as f64;

        self.spatial_idx.within(
            &[center.x as f64, center.y as f64, center.z as f64],
            radius_sqr,
            &squared_euclidean
        ).unwrap().iter().map(move |&(_, &idx)| &self.samples[idx]).collect()
    }

    pub fn iter_mut<'a>(&'a mut self) -> slice::IterMut<'a, S> {
        self.samples.iter_mut()
    }

    pub fn find_within_sphere_indexes(&self, center: Vector3<f32>, radius: f32) -> Vec<usize> {
        let radius_sqr = (radius * radius) as f64;

        self.spatial_idx.within(
            &[center.x as f64, center.y as f64, center.z as f64],
            radius_sqr,
            &squared_euclidean
        ).unwrap().iter().map(move |&(_, &idx)| idx).collect()
    }
}

